# 객체 지향 프로그래밍 입문
이 글은 [최범균님의 Inflearn 강의](https://www.inflearn.com/course/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9E%85%EB%AC%B8/dashboard)를 학습한 내용을 정리하였습니다.

# 기능과 책임 분리 맛보기

하나의 기능은 여러 하위 기능으로 분해할 수 있다.

맛보기로 **암호 변경** 프로세스를 통해 확인해보자.

![](https://images.velog.io/images/hansoleee/post/62a51b68-796c-4dac-8698-4df219cb1ffe/%EA%B8%B0%EB%8A%A5%EB%B6%84%EB%A6%AC%EC%98%8801.png)

암호를 변경 기능은 아래 2개의 기능으로 분해할 수 있다.

1. **변경 대상 조회**
2. **대상 암호 변경**

그리고 **변경 대상 조회** 기능은 변경 대상 존재 여부에 따라 **변경 대상 반환**과 **오류 반환** 기능으로 나눠질수 있다.

**대상 암호 변경** 기능은 또 아래 2개의 기능으로 분해할 수 있다.

1. **암호 일치 여부**
2. **암호 데이터 변경**

## 기능을 제공할 주체 정하기

> **기능을 분리**하고 **제공할 주체를 결정**하는 것은 **객체 지향 설계의 기본 과정**이다.

위에서 분해한 기능들을 제공할 객체를 정해자.  
결과는 아래와 같다.

![](https://images.velog.io/images/hansoleee/post/82bb724b-8b9d-4f1e-b763-30a7169ba952/%EA%B8%B0%EB%8A%A5%EC%A3%BC%EC%B2%B4%EC%84%A0%EC%A0%9501.png)

**암호 변경 전체 기능**은 `ChangePasswordService`가 제공한다.  
**변경 대상을 조회**하는 기능은 `MemberRepository`가 제공한다.  
**대상 암호를 변경**하는 기능은 `Member`가 제공한다.

위 설계를 바탕으로 코드를 작성해보자.

<pre>
public class ChangePasswordService {
  public Result <span style="color:blue">changePassword</span>(String id, String oldPw, String newPw) {
    Member mem = <span style="color:blue">memberRepository.findOne(id)</span>;
    if (isEmpty(mem)) return Result.NO_MEMBER;
    
    try {
      <span style="color:blue">mem.changePassword(oldPw, newPw)</span>;
      return Result.SUCCESS;
    } catch (BadPasswordException ex) {
      return Result.BAD_PASSWORD;
    }
  }
}
</pre>

위 코드를 보면 **ChangePasswordService 객체**에서 **암호 변경** 기능을 제공하고  
**암호 변경** 기능을 제공하기 위해 **MemberRepository**, **Member** 객체와 협력하는 것을 볼 수 있다.

> **주의사항**  
> 클래스 또는 메소드가 커지면 절차 지향의 문제가 발생할 수 있다.  
> \>\> 큰 클래스인 경우 많은 필드를 많은 메소드가 공유하게 된다.    
> \>\> 큰 메소드인 경우 많은 변수를 많은 코드가 공유하게 된다.
>
> **해결방법**
> 적절한 시기에 책임에 따라 코드 분리를 해야한다.

# 기능과 책임을 분리하는 방법

클래스 또는 메소드가 너무 커지지 않도록 분리하는 몇 가지 방법을 알아보겠다.

## 패턴 적용

알아볼 첫 번째 방법은 **패턴 적용**이다.

이 방법은 **전형적인 역할 분리**를 사용한다.
아래의 예를 보자.

- 간단한 웹
  간단한 웹의 경우 _컨트롤러_, _서비스_, _DAO_의 계층 분리 방식을 사용할 수 있다.

- 복잡한 도메인
  도메인이 복잡하다면 모델을 _Entity_, _Value_, _Repository_, _Domain Service_로 분리하여 사용할 수 있다.

- AOP
  여러 기능에 공통으로 포함된 기능은 Aspect를 사용해서 분리할 수 있다.

- GoF
  디자인 패턴을 사용해서 여러 기능을 분리할 수 있다.

## 계산 분리

두 번째 방법은 **계산 분리**이다.

상품 결제중 포인트 계산하는 코드의 예를 통해 알아보자.  
아래의 코드를 보면

![](https://images.velog.io/images/hansoleee/post/bba310c7-ee74-4e0c-b2a7-54fa0065d5c9/%EA%B3%84%EC%82%B0%EB%B6%84%EB%A6%AC01.png)

왼쪽의 빨간색 코드가 포인트를 계산하는 로직이다.  
이를 오른쪽 하단의 **PointCalculator 객체로 분리**하고  
기존의 코드는 PointCalculator의 기능을 사용하도록 한다.

## 외부 연동 분리

세 번째 방법은 네트워크, 메세징, 파일 등의 **외부 연동 코드를 분리**하는 것이다.

HTTP API를 분리하는 예를 통해 알아보자.

![](https://images.velog.io/images/hansoleee/post/9dde57e7-f70f-406d-9f8f-787394433907/%EC%97%B0%EB%8F%99%EB%B6%84%EB%A6%AC01.png)

Http 연동 코드를 별도의 클래스로 분리하여 사용한다.

## 조건별 분기 추상화

마지막 방법은 if-else는 추상화하는 것이다.

![](https://images.velog.io/images/hansoleee/post/af209c1d-1738-46fa-be66-842bfdbe8c6d/%EC%A1%B0%EA%B1%B4%EB%B6%84%EA%B8%B0%EC%B6%94%EC%83%81%ED%99%9401.png)

연속적인 if-else 블록의 로직이 비슷하다면 공통 기능을 뽑아 추상화한다.