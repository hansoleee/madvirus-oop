# 객체 지향 프로그래밍 입문
이 글은 [최범균님의 Inflearn 강의](https://www.inflearn.com/course/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9E%85%EB%AC%B8/dashboard)를 학습한 내용을 정리하였습니다.

# 의존

## 의존이란

**의존**이란 기능 구현을 위해 다른 구성 요소를 사용하는 것을 말한다.

의존의 예는 **객체 생성**, **메소드 호출**, **데이터 사용** 등이 있다.

**의존한다는 것**은 **변경이 전파될 가능성이 있음**을 의미한다.  
예를들어 아래와 같은 경우

- 호출하는 메소드의 파라미터가 변경
- 호출하느 메소드에서 발생하는 예외가 추가

의존하는 객체의 코드도 변경이 필요하다.

## 주의 사항

### 순환 의존

일단 의존하게되면 변경이 전파될 가능성이 있기 때문에 의존이 순환되지 않도록 해야된다.

> **순환 의존**이란  
> 아래 그림과 같이 의존관계가 순환하는 것을 말한다.  
> ![](https://images.velog.io/images/hansoleee/post/e7f6326d-52b7-47fb-8684-1dc6bfda92dc/%EC%88%9C%ED%99%98%EC%9D%98%EC%A1%B401.png)
>
> A가 B에 의존하고 B는 C 그리고 C는 다시 A에 의존하고 있다.
>
> 만약 A에 변경이 일어났다면, B에 영향을 주고 이어서 C에 영향을 주고 다시 A에 영향을 줄 수 있다.  
> 위와 같은 현상을 방지하기 위해 순환 의존은 _클래스_, _패키지_, _모듈_ 등 모둔 수준에서 발생하지 않도록 설계해야 한다.

### 많은 의존

순환 의존뿐만 아니라 의존하는 곳이 많아도 변경의 포인트가 굉장히 많아진다.
아래 그림을 통해 알아보자.

![](https://images.velog.io/images/hansoleee/post/dc3ef08b-7cab-473a-bcff-f8df09790869/%EB%A7%8E%EC%9D%80%EC%9D%98%EC%A1%B401.png)

X는 A, B, C, D, E, F를 의존하고 있다.  
만약 A ~ F 중에서 A, B, E에서 변경이 일어난다면 X는 의존 대상의 변경에 영향을 받을 수 있다.  
그래서 **의존 대상**은 **최소한이 되도록 설계**해야 한다.

## 의존 최소화 방법

한 클래스에서 많은 기능을 제공하는 경우에 의존 대상이 많아질 수 있다.  
이 경우에 의존 대상을 줄일 수 있는 방법을 알아보자.

### 기능이 많은 경우

예제 코드는 아래와 같다.

![](https://images.velog.io/images/hansoleee/post/e9e0bf05-1327-42f8-b25a-64c572da1cb1/%EB%A7%8E%EC%9D%80%EA%B8%B0%EB%8A%A501.png)

#### 발생 문제

이런 경우 각 기능마다 의존하는 대상이 다를 수 있다.  
위 코드에서는 regist()와 changePw()가 의존하는 대상이 각각 RegReq, ChangeReq로 다르다.

이런 구조에서는 한 기능을 변경하는 과정에서 다른 기능에 영향을 줄 가능성이 있다.
예를들어, changePw()의 로직을 변경할 때 blockUser()의 코드를 변경해야되는 경우가 생길 수 있다.
이렇게 다른 기능에 의존하게 되는 경우까지 겹치면 독립된 기능 테스트 작성도 힘들어진다.

#### 해결 방법

기능이 많은 경우 해결 방법은 기능 별로 분리하는 것이다.

![](https://images.velog.io/images/hansoleee/post/393855b8-2a6f-455b-8524-68913b8222f0/%EB%A7%8E%EC%9D%80%EA%B8%B0%EB%8A%A5%ED%95%B4%EA%B2%B001.png)

위와 같이 기능 별로 분리하면 아래와 같은 장점이 있다.

1. 각 클래스마다 필요한 의존이 줄어든다. (~~단, 클래스는 증가한다.~~)
2. 개별 기능을 테스트하는 것이 쉬워진다.

### 의존 대상이 많은 경우

예제 코드는 아래와 같다.

![](https://images.velog.io/images/hansoleee/post/c127d757-09f8-4409-8d7f-d0b988943f9c/%EB%A7%8E%EC%9D%80%EC%9D%98%EC%A1%B4%ED%95%B4%EA%B2%B001.png)

#### 해결 방법

몇 가지 의존 대상을 **단일 기능으로 묶어**보자.

왼쪽 그림에서 아래 2개의 의존 대상은 민원과 관련되어있다.  
이 2개의 항목을 오른쪽 그림처럼 하나의 민원으로 **기능을 추상화**하면 의존 대상이 줄어든다.

***

여기까지는 의존 대상이 많을 경우 생기는 문제와 해결방법에 대하여 알아보았다.  
다음은 의존 대상을 주입하는 방법에 대해 알아보자.

# DI (Dependency Injection)

> DI의 **필요성**  
> 의존 대상을 직접 생성할 경우 생성 클래스가 바뀌면 의존하는 코드도 바뀌게 된다.
>
> 따라서, 코드를 변경하지 않기 위해서 의존 대상을 직접 생성하지 않는 방법이 필요하다.  
> 방법은 아래와 같다.
>
> - 팩토리, 빌더
> - 의존 주입 (Dependency Injection)
> - 서비스 로케이터 (Service Locator)
>
> 이 글에서는 **의존 주입** 방식을 알아본다.

## 의존 주입 방법

의존하는 대상을 직접 생성하지 않고, 생성자 또는 메소드를 이용해서 의존성을 주입받는다.  
아래의 DI 예제 코드를 보자.

![](https://images.velog.io/images/hansoleee/post/bd969989-17af-45a5-84e8-6d69496950ff/DI01.png)

왼쪽의 ScheduleService는 2개의 의존 대상을 갖는다.
그리고 의존성 주입 방식은 **생성자 방식**, **Setter 방식**을 사용한다.

- 생성자 방식으로 UserRepository
- Setter 방식으로 Calculator

를 주입받고 있다.

이렇게 의존 주입 방식을 사용하면 얻는 **장점**은 **UserRepository의 구현체가 변경**되더라도 **ScheduleService의 코드는 변경하지 않아도 된다**.

## DI와 조립기(Assembler)

> **조립기**란  
> 의존성 주입을 위해 객체를 생성하고 의존성 주입을 담당하는 객체이다.
>
> 조립기 예: 스프링 프레임워크

아래의 예는 스프링 프레임워크에서 조립기를 이용해 DI를 수행하는 코드이다.

![](https://images.velog.io/images/hansoleee/post/7b8223f7-1b9d-4343-9780-9c36384f8f7a/%EC%A1%B0%EB%A6%BD%EA%B8%B001.png)

왼쪽의 코드는 스프링에서 객체를 생성하고 의존 대상을 주입하는 설정 클래스이다.  
설정 코드를 이용한 ApplicationContext 조립기를 생성한다.

의존성 주입은 설정 클래스를 이용해서 조립기를 초기화하는 시점에 해준다.  
(초기화 이후에는 조립기에서 필요한 객체를 구하고 사용하면 된다.)

## DI 장점

DI의 장점을 알아보자.

### OCP가 지켜진다.

의존 대상이 바뀌면 조립기(설정)만 변경하면 된다.

![](https://images.velog.io/images/hansoleee/post/64f8934e-8d6e-4aa9-b9b1-9de670c46e42/DI%EC%9E%A5%EC%A0%9001.png)

위 코드는 OrderService의 Notifier 구현체를 Email에서 Email + Kakao 변경하는 예이다.

왼쪽 하단의 Config를 보면 EmailNotifier를 주입했다.
OrderService에서 Notifier를 Email + Kakao을 사용하도록 변경하려면 Config에서 Notifier를 CompositeNotifier로 바꿔주면 된다.

### 테스트가 쉽다.

DI 방식을 이용하면 의존 객체를 주입할 수 있기 때문에 대역 객체를 사용해서 테스트가 가능하다.

아래의 예는 ScheduleService 테스트를 위해 UserRepository를 주입해주는 테스트 코드이다.

![](https://images.velog.io/images/hansoleee/post/5f10b020-58f9-4aa1-948b-2487819c3e0a/DI%EC%9E%A5%EC%A0%9002.png)

만약 회원 관리를 위한 Repository가 DI 방식이 아니었더라면 테스트를 위해 회원 DB까지 연동해야 될 것이다.

대역 객체를 사용했을 때 추가적인 장점은 원하는 상태로 초기화한 객체를 주입해 다양한 케이스를 테스트할 수 있다.

# 정리

의존과 DI에 대해서 알아보았다.

의존 관리에 주의사항 2가지 경우를 지키지 않을 때 발생하는 문제에 대해 정리하였다.

1. 순환 의존
2. 많은 의존

그리고 의존이 많은 경우 최소화하는 2가지 방법에 대해서 알아보고 DI가 필요한 이유에 대해서 정리하였다.

** 의존 객체를 최소화하도록 설계하고 의존 객체는 주입받도록 코드를 작성하자.**